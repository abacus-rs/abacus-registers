//! Implementation for the Abacus procedural macro.
//!
//! This is responsible for parsing DSL inputs and auto-generating the type-stated
//! tock-registers (as Abacus is a wrapper around tock-registers). The autogenerated
//! code assumes the user of this proc-macro has tock-registers 0.10.0 as a dependency.
//!
//! Usage:
//! The proc macro consists of two parts to annotate a peripheral register block:
//! 1) `process_register_block` macro to annotate the peripheral register block struct.
//! 2) `RegAttributes` macro to define the peripheral states, registers, and transitions.
//!
//! #[repr(C)]
//! #[process_register_block(
//!     peripheral_name = "Nrf5xTemp",
//!     register_base_addr = 0x4000C000,
//!     states = [              <------------ Define peripheral states
//!         (Off),
//!         (Reading),
//!     ]
//! )]
//!
//!

mod generating;
mod macro_input;
mod parsing;
mod register;

use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::{parse_macro_input, DeriveInput, Field, Type};

use std::collections::HashSet;

use crate::generating::generate_state_enum;
use crate::macro_input::MacroInput;
use crate::register::Register;

#[proc_macro_attribute]
pub fn process_register_block(attr: TokenStream, item: TokenStream) -> TokenStream {
    let parsed_input = parse_macro_input!(attr as MacroInput);
    let register = format_ident!("{}Registers", parsed_input.peripheral_name);
    let internal_register = format_ident!("Block");
    let state_enum_ident = format_ident!("{}StateEnum", parsed_input.peripheral_name);

    let mut result = add_imports();
    result.extend(generate_register_wrapper(&register, &internal_register));
    result.extend(generate_state_enum(
        &parsed_input.state_definitions,
        &register,
        &state_enum_ident,
    ));

    let (states_generated, _) = parsed_input.generate_states(&register, &state_enum_ident);
    result.extend(states_generated);

    let ast: DeriveInput =
        syn::parse(item).expect("Abacus Macro - Error Parsing Provided AST of register struct.");
    let data = match &ast.data {
        syn::Data::Struct(data) => data,
        _ => panic!("Abacus Macro - Unsupported type; must be a struct."),
    };

    let (field_details, reg_vec) = process_struct_fields(&data.fields);
    result.extend(generate_register_bindings(&reg_vec, &register));
    result.extend(register_type_definitions());
    result.extend(quote! {
        #[repr(C)]
        pub struct #internal_register<S: State> {
            #(#field_details),*
        }
    });

    result.into()
}

fn add_imports() -> proc_macro2::TokenStream {
    quote!(
        use abacus_registers::{State, SubState, StateEnum, Reg, SyncState, TransientStateReg, AbacusStaticRef};
        use core::marker::PhantomData;
        use core::mem::transmute;
        use core::ops::Deref;
        use abacus_registers::tock_registers::{
            fields::FieldValue, UIntLike, RegisterLongName, fields::Field, LocalRegisterCopy,
            interfaces::ReadWriteable,
        };
        use core::convert::TryFrom;
    )
}

fn generate_register_wrapper(
    register: &syn::Ident,
    internal_register: &syn::Ident,
) -> proc_macro2::TokenStream {
    quote! {
        pub struct #register<S: State> {
            reg:  AbacusStaticRef<#internal_register<S>>,
        }

        impl <S: State> #register<S> {
            pub const unsafe fn new(base_addr: usize) -> #register<S> {
                let reg = unsafe { AbacusStaticRef::new(base_addr as *const #internal_register<S>) };
                #register { reg }
            }
        }

        impl <S: State> Deref for #register<S> {
            type Target = #internal_register<S>;
            fn deref(&self) -> &#internal_register<S> {
                self.reg.deref()
            }
        }
    }
}

fn process_struct_fields(fields: &syn::Fields) -> (Vec<proc_macro2::TokenStream>, Vec<Register>) {
    let mut reg_vec = Vec::new();
    let field_details: Vec<_> = fields
        .iter()
        .map(|field| {
            let (tokens, mut registers) = process_field(field);
            reg_vec.append(&mut registers);
            tokens
        })
        .collect();
    (field_details, reg_vec)
}

fn process_field(field: &Field) -> (proc_macro2::TokenStream, Vec<Register>) {
    let field_type = field.ty.clone();
    let field_name = field
        .ident
        .clone()
        .expect("Abacus Macro - Error in register struct field, expected field name.");

    let requires_gen = field
        .attrs
        .iter()
        .any(|attr| attr.path().is_ident("RegAttributes"));

    let field_attr: Vec<_> = field
        .attrs
        .iter()
        .filter_map(|attr| {
            if !attr.path().is_ident("RegAttributes") {
                Some(quote! {#attr})
            } else {
                None
            }
        })
        .collect();

    if !requires_gen {
        return (
            quote! { #(#field_attr)* pub #field_name: #field_type },
            vec![],
        );
    }

    let reg_attr_vec: Vec<_> = field
        .attrs
        .iter()
        .filter_map(|attr| {
            if attr.path().is_ident("RegAttributes") {
                attr.parse_args::<parsing::RegisterAttributes>().ok()
            } else {
                None
            }
        })
        .collect();

    let Type::Path(type_path) = field_type.clone() else {
        panic!("unreachable b");
    };

    let segment = type_path
        .path
        .segments
        .last()
        .expect("Abacus Macro - Error, parsing tock-registers field.");

    let syn::PathArguments::AngleBracketed(args) = &segment.arguments else {
        panic!("Abacus Macro - Error, parsing expects tock-registers types to have 2 generics.");
    };

    let generic_args = &args.args;
    if generic_args.len() != 2 {
        panic!("Abacus Macro - Error, parsing expects tock-registers types to have 2 generics.");
    }

    let register_shortname = generic_args[1].clone();
    let register_bitwidth = match &generic_args[0] {
        syn::GenericArgument::Type(Type::Path(tp)) => tp
            .path
            .segments
            .first()
            .expect(
                "Abacus Macro - Error, parsing expects tock-registers types to have 2 generics.",
            )
            .ident
            .clone(),
        _ => panic!("Abacus Macro - Error, parsing generic arg 0."),
    };

    let mut output = proc_macro2::TokenStream::new();
    let mut registers = Vec::new();
    let mut first_item = true;

    for reg_attr in reg_attr_vec {
        registers.push(Register {
            name: field_name.clone(),
            valid_states: reg_attr.valid_states,
            register_shortname: register_shortname.clone(),
            register_type: reg_attr.register_type.clone(),
            register_bitwidth: register_bitwidth.clone(),
        });

        let reg_type = format_ident!("{}Register", &reg_attr.register_type.to_ident());
        if first_item {
            output.extend(quote! {
                #(#field_attr)*
                pub #field_name: #reg_type<#register_bitwidth, #register_shortname, S>
            });
            first_item = false;
        }
    }

    let output = if output.is_empty() {
        quote! { #(#field_attr)* pub #field_name: #field_type }
    } else {
        output
    };

    (output, registers)
}

fn generate_register_bindings(
    reg_vec: &[Register],
    register: &syn::Ident,
) -> proc_macro2::TokenStream {
    let mut result = proc_macro2::TokenStream::new();
    let mut seen = HashSet::new();
    for reg in reg_vec {
        let binding = reg.generate_register_op_bindings(register);
        if seen.insert(binding.clone().to_string()) {
            result.extend(binding);
        }
    }
    result
}

fn register_type_definitions() -> proc_macro2::TokenStream {
    quote! {
        pub enum RegisterResult<A: Reg, B: Reg> {
            Ok(A),
            Err(B),
        }

        impl <A: Reg, B: Reg> From<Result<A, B>> for RegisterResult<A, B> {
            fn from(result: Result<A, B>) -> Self {
                match result {
                    Ok(val) => RegisterResult::Ok(val),
                    Err(err) => RegisterResult::Err(err),
                }
            }
        }

        impl <A: Reg, B: Reg> RegisterResult<A, B> {
            fn into_closure_return<C, D>(self) -> Result<C, D>
            where
                C: StateEnum + From<A>,
                D: StateEnum + From<B>,
            {
                match self {
                    RegisterResult::Ok(val) => Ok(val.into()),
                    RegisterResult::Err(reg) => Err(reg.into())
                }
            }
        }

        pub struct StateChangeRegister<T: UIntLike, R: RegisterLongName, S: State> {
            pub(crate) reg: ReadWrite<T, R>,
            associated_state: PhantomData<S>,
        }

        struct ReadWriteRegister<T: UIntLike, R: RegisterLongName, S: State> {
            reg: ReadWrite<T, R>,
            associated_state: PhantomData<S>,
        }

        struct ReadOnlyRegister<T: UIntLike, R: RegisterLongName, S: State> {
            reg: ReadOnly<T, R>,
            associated_state: PhantomData<S>,
        }

        struct WriteOnlyRegister<T: UIntLike, R: RegisterLongName, S: State> {
            reg: WriteOnly<T, R>,
            associated_state: PhantomData<S>,
        }
    }
}
